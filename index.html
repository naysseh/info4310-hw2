<!DOCTYPE html>
<html>
  <head>
    <title>HW 2 - Amazon Bestsellers</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
    <link rel="stylesheet" type="text/css" href="styles/site.css">
  </head>
  <body>
    <div>
      <div class="title">
        <h1>Amazon Bestsellers At A Glance</h1>
      </div>
      <div class="main-view">
        <svg id="bubble" width="600" height="500"></svg>
        <div class="right-side">
          <div class="filters">filters go around here? change this if it's wrong just putting a placeholder</div>

          <div id="panel"></div>
        </div>
      </div>
    </div>


    <script>
      const bubblePlot = d3.select("svg#bubble");
      const bubbleHeight = bubblePlot.attr("height");
      const bubbleWidth = bubblePlot.attr("width");
      console.log("height", bubbleHeight);
      // didn't do margins or anything.. will decide if we need later

      // chart area g tag to add stuff into
      let bubbleChartArea = bubblePlot.append("g");

      const requestData = async function () {

        const data = await d3.csv("data/bestsellers.csv", d3.autoType);

        // log data
        console.log(data);

        let authors = data.map(d => d.Author);
        let authorsUnique = Array.from(new Set(authors));
        let authorsTotal = d3.group(data, d => d.Author); //this is basically a map version of the final data structure we want

        // turning the map into an array of dictionaries
        // form is: authorData = [{author: "name", books: [{Name: '', Author: '', User Rating: 00, Reviews: 00, Price: 0}, {}, ... ]}]
        let authorData = [];
        authorsUnique.forEach(d => {
          authorData.push({author: d, books: authorsTotal.get(d)});
        });
        console.log("data final structure", authorData);

        // create data rollup for the counts of each author occurence in the dataset
        // authorOccurences has a length of 248 (i.e. 248 unique authors found on these lists)
        // let authorOccurences = d3.rollups(data, v => v.length, d => d.Author);

        let authorExtent = d3.extent(authorData, d => d['books'].length);
        // docs on scale sqrt https://www.d3indepth.com/scales/
        let radiusScale = d3.scaleSqrt()
                            .domain(authorExtent)
                            .range([5,40]); //change this depending on how big we want the circles

        //create simulation for the author bubble plot 
        let simulation = d3.forceSimulation()
                           .nodes(authorData)
                          //  .force("center", d3.forceCenter(bubbleWidth/2.0, bubbleHeight-200))
                           .force("center", d3.forceManyBody().strength(-3))
                           .force("boundary", forceBoundary(0, 0, 600, 480))
                          //  .force('x', d3.forceX(600 / 2).strength(0.5))
                          //  .force('y',  d3.forceY(500 / 2).strength(0.8))
                          //  .force("xpos", d3.forceX(bubbleWidth/2).strength(0.1))
                          //  .force("ypos", d3.forceY(bubbleHeight-20).strength(.1))
                           .force("collision", d3.forceCollide().radius(d => radiusScale(d['books'].length) + 2))
                           .on("tick", renderOnTick);

        function wrap(text, width) {
          text.each(function () {
              var text = d3.select(this),
                  words = text.text().split(/\s+/).reverse(),
                  word,
                  line = [],
                  lineNumber = 0,
                  lineHeight = 1,
                  x = text.attr("x"),
                  y = text.attr("y"),
                  dy = 0, 
                  tspan = text.text(null)
                              .append("tspan")
                              .attr("x", x)
                              .attr("y", y)
                              .attr("dy", dy + "em");
              while (word = words.pop()) {
                  line.push(word);
                  tspan.text(line.join(" "));
                  if (tspan.node().getComputedTextLength() > width) {
                      line.pop();
                      tspan.text(line.join(" "));
                      line = [word];
                      tspan = text.append("tspan")
                                  .attr("x", x)
                                  .attr("y", y)
                                  .attr("dy", ++lineNumber * lineHeight + dy + "em")
                                  .text(word);
                  }
              }
          });
        
        }
        //put bubbles into a function 
        function renderOnTick() {
          // joining data to create the bubble plot 
          let authorBubbles = bubbleChartArea.selectAll("circle.bubble")
                                            .data(authorData)
                                            .join(enter => 
                                                enter.append("circle")
                                                .attr("class", "bubble")
                                                .attr("cx", 0)
                                                .attr("cy", 0) //start sim at bottom?
                                                .attr("r", d => radiusScale(d['books'].length))
                                                .style("fill", "lightpink"))
                                            .attr("transform", d => `translate(${d.x},${d.y})`);
                                           
          let bubbleText =bubbleChartArea.selectAll("text.bubble-label")
                       .data(authorData)
                       .join("text")    
                       .attr("class", "bubble-label")
                       .style("text-anchor", "middle")
                       .style("text-align", "center")
                       .style("white-space", "normal")
                       .attr("x", function (d) { return d.x })
                       .attr("y", function (d) { return d.y-14 })
                      //  .attr("transform", d => `translate(${d.x},${d.y})`)
                       .style("font-size", "10px")
                       .text(function (d) {
                        if (radiusScale(d['books'].length) > 25) {
                          return d.author;
                       } else {return ""}})
                       .call(wrap, 14);                       
        }
        
        renderOnTick();

        let bubbles = bubbleChartArea.selectAll("circle.bubble")
        bubbles.on("mouseover", function(event, d) {
          d3.select(this)
            .transition().duration(200)
            .attr("stroke", "black")
            .attr("stroke-width", 3)
            .style("fill", "#dd6688" ) ;

          updatePanel(d);
        });
        bubbles.on("mouseout", function(event, d) {
          d3.select(this)
            .transition().duration(200)
            .attr("stroke", "")
            .attr("stroke-width", 1)
            .style("fill", "lightpink") ;

        
          updatePanel( {} );
    
        });

        let authorName = d3.select("#panel").append("h3");
        let table = d3.select("#panel").append("table");

        function updatePanel(row) {
          let rowCopy = Object.assign({},row);
          console.log(rowCopy) 
          let author = rowCopy.author;
          authorName.text(author);
          delete rowCopy.author;
          let iterate = rowCopy["books"] != null ? rowCopy["books"] : []
          let rows = table.selectAll("tr").data(iterate)
                            .join( enter => enter.append("tr"),
                                  update => update.selectAll("td").remove(), 
                                  exit => exit.remove() ); 
          
          rows.append("td").append("strong").text( d => d["Name"]);
          rows.append("td").text( d => "Placed in "+d["Year"] );
          rows.append("td").text( d => "Price: $"+d["Price"] ); 
          rows.append("td").text( d => "User Rating: " + d["User Rating"]  ); 
        }


      }

      requestData();




    </script>
  </body>
</html>
