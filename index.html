<!DOCTYPE html>
<html>
  <head>
    <title>HW 2</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
    <link rel="stylesheet" type="text/css" href="styles/site.css">
  </head>
  <body>
    <div>
      <div class="main-view">
        <svg id="bubble" width="600" height="500"></svg>
        <div class="right-side">
          <div class="filters">filters go around here? change this if it's wrong just putting a placeholder</div>

          <div class="modal">detailed info area</div>
        </div>
      </div>
    </div>


    <script>
      const bubblePlot = d3.select("svg#bubble");
      const bubbleHeight = bubblePlot.attr("height");
      const bubbleWidth = bubblePlot.attr("width");
      console.log("height", bubbleHeight);
      // didn't do margins or anything.. will decide if we need later

      // chart area g tag to add stuff into
      const bubbleChartArea = bubblePlot.append("g");

      const requestData = async function () {

        const data = await d3.csv("data/bestsellers.csv", d3.autoType);

        // log data
        console.log(data);

        let authors = data.map(d => d.Author);
        let authorsUnique = Array.from(new Set(authors));
        let authorsTotal = d3.group(data, d => d.Author); //this is basically a map version of the final data structure we want
        console.log(authorsUnique);

        console.log("total", authorsTotal);

        console.log("testing", authorsTotal.get("Stephen King"));

        // turning the map into an array of dictionaries
        // form is: authorData = [{author: "name", books: [{Name: '', Author: '', User Rating: 00, Reviews: 00, Price: 0}, {}, ... ]}]
        let authorData = [];
        authorsUnique.forEach(d => {
          authorData.push({author: d, books: authorsTotal.get(d)});
        });
        console.log("data final", authorData);

        // create data rollup for the counts of each author occurence in the dataset
        // authorOccurences has a length of 248 (i.e. 248 unique authors found on these lists)
        let authorOccurences = d3.rollups(data, v => v.length, d => d.Author);
        // the same thing as authorOccurences except it uses a map instead of a 2d array ... idk
        let authorOccurences1 = d3.rollup(data, v => v.length, d => d.Author);

        console.log(authorOccurences);


        // scales and extents
        let authorExtent = d3.extent(authorOccurences, d => d[1]);
        // docs on scale sqrt https://www.d3indepth.com/scales/
        let radiusScale = d3.scaleSqrt()
                            .domain(authorExtent)
                            .range([0,40]); //change this depending on how big we want the circles

        //create simulation for the author bubble plot 
        let simulation = d3.forceSimulation()
                           .nodes(authorOccurences)
                          //  .force("center", d3.forceCenter(bubbleWidth/2.0, bubbleHeight-200))
                           .force("center", d3.forceManyBody().strength(-3))
                           .force("boundary", forceBoundary(0, 0, 600, 480))
                          //  .force('x', d3.forceX(600 / 2).strength(0.5))
                          //  .force('y',  d3.forceY(500 / 2).strength(0.8))
                          //  .force("xpos", d3.forceX(bubbleWidth/2).strength(0.1))
                          //  .force("ypos", d3.forceY(bubbleHeight-20).strength(.1))
                           .force("collision", d3.forceCollide().radius(d => radiusScale(d[1]) + 2))
                           .on("tick", renderOnTick);

  

        //put bubbles into a function 
        function renderOnTick() {
          // joining data to create the bubble plot 
          let authorBubbles = bubbleChartArea.selectAll("circle.bubble")
                                            .data(authorOccurences)
                                            .join(enter => 
                                                enter.append("circle")
                                                .attr("class", "bubble")
                                                .attr("cx", 0)
                                                .attr("cy", 0) //start sim at bottom?
                                                .attr("r", d => radiusScale(d[1]))
                                                .style("fill", "lightpink"))
                                            .attr("transform", d => `translate(${d.x},${d.y})`);
        }
        renderOnTick();

      }

      requestData();




    </script>
  </body>
</html>
