<!DOCTYPE html>
<html>
  <head>
    <title>HW 2</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
    <!-- <script src="https://raw.githubusercontent.com/sohamkamani/d3-force-gravity/master/d3-force-gravity.min.js" charset="utf-8"></script> -->
    <!-- <script src="https://unpkg.com/d3-force-attract@latest"></script> -->




    <style>
      
    </style>
  </head>
  <body>
    <div>
      <svg id="bubble" width="600" height="500"></svg>
    </div>

    <script>
      const bubblePlot = d3.select("svg#bubble");
      const bubbleHeight = bubblePlot.attr("height");
      const bubbleWidth = bubblePlot.attr("width");
      console.log("height", bubbleHeight);
      // didn't do margins or anything.. will decide if we need later

      // chart area g tag to add stuff into
      const bubbleChartArea = bubblePlot.append("g");
                                //  .attr("transform", `translate(${0}, ${0})`);

      const requestData = async function () {

        const data = await d3.csv("data/bestsellers.csv", d3.autoType);

        // log data
        console.log(data);

        // create data rollup for the counts of each author occurence in the dataset
        // authorOccurences has a length of 248 (i.e. 248 unique authors found on these lists)
        let authorOccurences = d3.rollups(data, v => v.length, d => d.Author);

        // the same thing as authorOccurences except it uses a map instead of a 2d array ... idk
        let authorOccurences1 = d3.rollup(data, v => v.length, d => d.Author);

        console.log(authorOccurences);
        // console.log("map", authorOccurences1);

        // change the data structure to be a dictionary containing author, and array of book titles
        // ex: dictEx = {author: "george orwell", books: ['book1', 'book2', 'book3'] }
        // to get the count of book occurences, take length of dictEx.books

        // scales and extents
        let authorExtent = d3.extent(authorOccurences, d => d[1]);
        // docs on scale sqrt https://www.d3indepth.com/scales/
        let radiusScale = d3.scaleSqrt()
                            .domain(authorExtent)
                            .range([0,40]); //change this depending on how big we want the circles

        //create simulation for the author bubble plot 
        let simulation = d3.forceSimulation()
                           .nodes(authorOccurences)
                          //  .force("center", d3.forceCenter(bubbleWidth/2.0, bubbleHeight-200))
                           .force("repulse", d3.forceManyBody().strength(-3))
                           .force("boundary", forceBoundary(0, 0, 600, 480))
                          //  .force('x', d3.forceX(600 / 2).strength(0.5))
                          //  .force('y',  d3.forceY(500 / 2).strength(0.8))
                          //  .force("xpos", d3.forceX(bubbleWidth/2).strength(0.1))
                          //  .force("ypos", d3.forceY(bubbleHeight-20).strength(.1))
                           .force("collision", d3.forceCollide().radius(d => radiusScale(d[1]) + 2))
                           .on("tick", renderOnTick);

  

        //put bubbles into a function 
        function renderOnTick() {
          // joining data to create the bubble plot 
          let authorBubbles = bubbleChartArea.selectAll("circle.bubble")
                                            .data(authorOccurences)
                                            .join(enter => 
                                                enter.append("circle")
                                                .attr("class", "bubble")
                                                .attr("cx", 0)
                                                .attr("cy", 0) //start sim at bottom?
                                                .attr("r", d => radiusScale(d[1]))
                                                .style("fill", "lightpink"))
                                            .attr("transform", d => `translate(${d.x},${d.y})`);
        }
        renderOnTick();

      }

      requestData();




    </script>
  </body>
</html>
